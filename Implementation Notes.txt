

Steps to deploy using Kubernetes ------>>



Here are the steps to dockerize a microservices application using Kubernetes where you have a common module for shared POJO/DTO classes:


1. Create a Dockerfile for each microservice. This will build an image for that service.
2. For the common module, create a Dockerfile to build an image that just packages the JAR with the common classes.
3. Build Docker images for each of the microservices and the common module.
4. Push these images to a registry like Docker Hub so they are accessible to Kubernetes.
5. For deploying on Kubernetes, create Deployment and Service manifests for each microservice.
6. For the common module, create a Kubernetes ConfigMap containing the JAR file.
7. In the Deployments for other microservices, add a volume mount that maps this ConfigMap.
8. The JAR from the common module will be available to other microservices via this volume mount.
9. Deploy all the manifests to Kubernetes using kubectl.
10. The microservices will run with the shared common classes mapped via ConfigMap volume.


This allows you to leverage Kubernetes ConfigMaps to share common code across microservices in a decentralized way. Let me know if you need any examples or have additional questions!


——————————————


1. Create a basic spring boot application with data getting stored in mysql db and test the application through postman
2. Now, we first need to deploy mysql db instance to the K8s pod inside the k8s cluster
3. For that, execute ->  minikube start

To make Kubernetes read your local Docker repository (we gave permission to K8s to read my Docker repository) ->

eval $(minikube docker-env)   // To point your shell to minikube's docker-daemon, run this command OR it means we are syncing both docker and minikube


Execute ->  docker images to verify




Now, we need to pull the mysql image from the docker hub but we are not going to do it manually.

Instead, while creating the Deployment object using yaml configuration, we will specify the latest mysql version so that k8s Deployment object will take care of pulling the mysql image and it will run that image in a separate k8s pod.

So, we will create Deployment and Service object using yaml configuration.

db-deployment.yaml








docker tag registry-app-image:latest himsb/registry-app-image:latest


docker login -u himsb


prompt for pwd - Infy@2014



docker push himsb/registry-app-image:latest



In this example:
* myimage:latest is the name of the local Docker image you have built
* <dockerhub-username> is your Docker Hub username


The key steps are:
1. Tag the image with your Docker Hub username and repository name
2. Run docker login to authenticate with Docker Hub
3. Push the tagged image using docker push


This will upload your image to Docker Hub.
You can then reference this image in Kubernetes manifests by:


containers:
  - name: app
    image: <dockerhub-username>/myimage:latest


And Kubernetes will be able to pull the image from Docker Hub.






In browser, access the url using ip and port you got from kubectl get svc command ->


http://10.96.2.238:32527/orders


OR


Execute the command  minikube service <service_name> --url ->

This will return something like http://127.0.0.1:64198

Access this url in browser ->

http://127.0.0.1:64198/orders



Check health of each component using command ->

minikube dashboard






kubectl apply -f db1-deployment.yml



kubectl apply -f user-deployment.yml





Scale services using replicas ->

kubectl scale deployment user-service --replicas=3





kubectl get secrets




kubectl get configmap spring-boot-configmaps-demo-oyaml




kubectl apply -f commondtos-configmap.yml



kubectl get configmaps



echo commondtos-service.jar | base64  (to generate base64 encoded version of jar file)





- name: TRANSFORMER_MODE
           valueFrom:
             configMapKeyRef:
               name: autobots-config
               key: transformer.mode





apiVersion: v1
kind: ConfigMap
metadata:
 name: autobots-config
 namespace: default
data:
 transformer.mode: robot





ConfigMaps —————


https://developers.redhat.com/blog/2017/10/03/configuring-spring-boot-kubernetes-configmap


https://dzone.com/articles/configuring-java-apps-with-kubernetes-configmaps-a



https://piotrminkowski.com/2019/12/20/microservices-with-spring-cloud-kubernetes/



https://www.jhipster.tech/kubernetes/



https://cloud.spring.io/spring-cloud-static/spring-cloud-kubernetes/1.0.0.M2/single/spring-cloud-kubernetes.html









kubectl apply -f configmap.yaml


3.  Verify ConfigMap is created:
<!---->


kubectl get configmaps


4.  Create the deployment YAML (e.g. deployment.yaml) with the ConfigMap volume mount


5.  Apply the deployment:
<!---->



kubectl apply -f deployment.yaml



6.  Verify deployment is created:
<!---->



kubectl get deployments



7.  The pods will be created and mounted with the ConfigMap volume. You can verify it:
<!---->



kubectl describe pod <pod-name>



Check the "Volumes" section to ensure the ConfigMap volume is mounted correctly.



8. You can also log into the pod and check the contents:
<!---->


kubectl exec -it <pod-name> -- /bin/sh

cat /app/lib/common-1.0.jar


This should print the base64 decoded contents of the JAR file from the ConfigMap.





Command to get container name from pod name - 


kubectl get pod user-deployment-6cc579c98c-9w2cf -o jsonpath='{.spec.containers[*].name}'






-------------------------------------------------------------------------------------------------------------





https://blog.numericaideas.com/deploying-springboot-app-with-docker-and-kubernetes



https://www.kindsonthegenius.com/deploy-springboot-with-mysql-to-kubernetes-minikube-step-by-step-tutorial/



https://benstitou-anas.medium.com/deploy-java-spring-application-with-mysql-db-on-kubernetes-1e456271c6a1



https://codersee.com/deploy-kotlin-spring-boot-app-with-mysql-on-kubernetes/



https://blog.numericaideas.com/deploying-springboot-app-with-docker-and-kubernetes




https://github.com/himanshubector/Deploy-Spring-Boot-CRUD-Application-With-MySQL-on-K8S-cluster/blob/master/app-deployment.yaml




https://github.com/numerica-ideas/community/blob/master/kubernetes/springboot-docker-kubernetes-setup/kubernetes/app-deploy.yml



-------------------------------------------------------------------------------------------------------------





